# UPI NPCI Direct Integration

This is a short guide on how the API integrates within UPI.

## Contents

1. How UPI works
2. Some Common APIs
3. Device Registration
4. Entities
5. SSL, Signatures, Apache Configurations
6. Going to Production


## 1. How UPI Works

Every entity connected to UPI runs its own UPI server. Each of these
servers have the following information:

1. Their own SSL certificate, passed to NPCI
2. A signing key+certificate, with the cert provided to NPCI
3. An encryption key, with the public key passed to NPCI
4. A handle (@razor)
5. A IFSC bank code (RAZR)

The request response flow can be easily explained using hearbeat messages:

1. PSP server sends Hbt request to UPI
2. UPI responds back immediately with a 200 and a ack response (ack:ReqHbt)
3. UPI sends a RespHbt request to PSP
4. PSP responds back immediately with a 200 and a ack response (ack:respHbt)

As such, all APIs are designed to be asynchronous

## 2. Some Common APIs

The APIs are roughly divided into "Meta-API", and "Transaction related APIs"

| Meta APIs                        | Transactional APIs                            |
|----------------------------------|-----------------------------------------------|
| List Keys                        | Initiate Payment (ReqPay)                     |
| List PSPs                        | Set Credentials                               |
| List Verified Address Entities   | Auth Details                                  |
| Manage Verified Address Entities | Register Mobile (Set MPIN)                    |
| Validate Address                 | Balance Enquiry                               |
| List Account Providers           | OTP Request                                   |
| Check Txn Status(?)              | Request Pending Messages                      |
| HeartBeat Messages               | Request Txn Confirmation (?)Check TXN Details |
|                                  | Account List|


This is a very rough categorization, but basically: anything that a PSP can initiate on its own is a Meta API, while something that needs a device to be properly integrated is a Transactional API.

There are some workarounds via which you can directly call Transactional APIs as well.

## 3. Device Registration

The device registration process will be same irrespective of which backend we are using. The device registration involves the Customer/Device entities.

### Step 1 (Create Device)

A call to /devices creates a device with the following details:

- `challenge` (NPCI challenge generated by the SDK)
- `package_name`
- `os_version`
- `imei`

The return values include a `device.id` (prefix=`dev_`) and a `verification_token`

### Step 2 (Send SMS)

The verification token is sent via an SMS to our registered number.
The format for this is `VERIFY {verification_token}`.

### Step 3 (Verify Device)

Via a webhook from the SMS provider, we receive the following details:

1. `mobile`
2. `verification_token`

Using these 2 details, we can find the following:

1. **Device** (from verification token)
2. **Customer** (FindOrCreateCustomerByMobileNumber)

- The device gets linked the customer.
- The device status is changed to `verified`.
- A GetToken request to UPI is initiated. This request to UPI requires:

1. `challenge`
2. `package_name`
3. `mobile`
4. `imei`

The mobile number is acquired by the SMS provider, and the remaining values
were provided at the time of device registration.

### Step 4 (Register Device)

- The GetToken request is acknowledged by UPI.
- UPI hits us back with a token using the `RespListKeys` API

We find the correct device for this message, and change the following:

- Set `status` to `registered`
- Set `upi_token` to the one present in the request.

### Step 5 (Register on App)

The SDK is constantly polling the device, and completes registration
as soon as the `upi_token` is present in the response.

## 4. Entities

The primary entities that this covers:

- Device
- Customer
- Bank Account
- VPA

The relationships are:

- A customer has many devices.
- A customer has many Bank Accounts
- A customer has many VPA
- A VPA has a bank account

Because of this, the flow can take many forms and be changed as per requirements. There is no "strict order" of what is right here.


1. VPA can be registered independently of a Bank Account being present.
2. Bank Accounts can be fetched and linked to a customer independently.


The trick we use for this is to provide a default VPA to all of our customers. This VPA is used for any "non-payment" related requests. This lets us request bank account list for the customer, and initiate set MPIN requests for eg.

However, if there is a paymnent request that may result in the opposite party
seeing this VPA, then we make sure that the user has registered a VPA before going ahead with this.

The default VPA is never provided to the SDK.

## 5. SSL, Signatures, Apache Configurations, Encryption

### SSL

- We have provided our Wildcard SSL certificate to NPCI, so that is a requirement to setup a UPI instance as of now
- The cert is directly verified by them, and no chaining is required.
- We have NPCI's SSL cert as well, which we _can_ use to verify the SSL connection.
- However, we have `verify=false` as of now, because NPCI has a weird SSL cert issue (TODO: Expand and fix)
