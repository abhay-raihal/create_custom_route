<?php

namespace RZP\Gateway\Wallet\Olamoney;

use Carbon\Carbon;
use RZP\Exception;
use RZP\Constants\Mode;
use phpseclib\Crypt\RSA;
use phpseclib\Crypt\AES;
use RZP\Trace\TraceCode;
use RZP\Error\ErrorCode;
use RZP\Constants\Timezone;
use RZP\Constants\HashAlgo;
use RZP\Gateway\Base\Verify;
use RZP\Gateway\Wallet\Base;
use RZP\Models\Customer\Token;
use RZP\Models\Payment\Processor;
use RZP\Models\Payment as Payment;
use RZP\Gateway\Base\VerifyResult;
use RZP\Gateway\Wallet\Base\Action;
use RZP\Gateway\Wallet\Base\Entity;
use RZP\Gateway\Base as GatewayBase;
use RZP\Gateway\Base\AuthorizeFailed;
use RZP\Models\Payment as PaymentModel;
use RZP\Constants\Entity as ConstantEntity;
use RZP\Models\Payment\Status as PaymentStatus;

class Gateway extends Base\Gateway
{
    use AuthorizeFailed;

    const BALANCE_CACHE_KEY = 'gateway:olamoney_balance_%s';

    // 8 hours - 8 * 60 * 60 = 28
    const WALLET_ACCESS_TOKEN_EXPIRY = 28800;

    protected $gateway = 'wallet_olamoney';

    protected $topup = true;

    protected $version;

    protected $map = [
        Entity::EMAIL                   => Entity::EMAIL,
        Entity::CONTACT                 => Entity::CONTACT,
        ResponseFields::STATUS          => Entity::STATUS_CODE,
        ResponseFields::AMOUNT          => Entity::AMOUNT,
        Entity::RECEIVED                => Entity::RECEIVED,
        ResponseFields::TRANSACTION_ID  => Entity::GATEWAY_PAYMENT_ID,
    ];

    // Not used in power-wallet flow
    // Used only for topup which is via a redirect flow

    public function setGatewayParams($input, $mode, $terminal)
    {
        parent::setGatewayParams($input, $mode, $terminal); // TODO: Change the autogenerated stub

        $this->setVersion($terminal);
    }

    public function setVersion($terminal)
    {
        $this->version = $terminal['gateway_merchant_id2'];
    }

    public function eligibility(array $input)
    {
        $request = $this->getEligibilityRequest($input);

        $traceContent = $request;

        $traceContent['headers'] = '';

        $this->trace->info(
            TraceCode::GATEWAY_ELLIGIBILITY_REQUEST,
            [
                'request' => $traceContent,
            ]);

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->traceGatewayPaymentResponse(
            $content,
            $input,
            TraceCode::GATEWAY_ELLIGIBILITY_RESPONSE
        );

        $status = $content[ResponseFields::ELIGIBILITY][ResponseFields::STATUS_CODE];

        if (in_array($status, ResponseCode::$eligible , true) != true)
        {
            $errorCode = ResponseCode::getApiErrorCode($status);

            throw new Exception\GatewayErrorException(
                $errorCode,
                $status
            );
        }
    }

    public function authorize(array $input)
    {
        parent::authorize($input);

        $this->eligibility($input);

        if ($this->version !== 'v2')
        {
            $request = $this->getBillGeneratorRequest($input);

            return $request;
        }

        else
        {
            $content = $this->getAuthorizeRequestDataV2($input);

            $authorizeAttributes = $this->getCreateWalletAttributesV2($input);

            $this->createGatewayPaymentEntity($authorizeAttributes, Action::AUTHORIZE);

            $request = $this->getStandardRequestArray($content,'post','AUTHORIZE_V2');

            $this->traceGatewayPaymentRequest($request, $input);

            return $request;
        }
    }

    // Not used in power-wallet flow
    // Used only for topup which is via a redirect flow
    public function callback(array $input)
    {
        parent::callback($input);

        if ($this->version !== 'v2')
        {
            return $this->callbackTopupFlow($input);
        }

        else
        {
            return $this->callbackDebitFlow($input);
        }
    }

    public function refund(array $input)
    {
        parent::refund($input);

        $request = $this->getRefundRequest($input);

        $this->traceGatewayPaymentRequest(
            $request,
            $input,
            TraceCode::GATEWAY_REFUND_REQUEST);

        $request['headers'] = $this->getRequestHeaders();

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->traceGatewayPaymentResponse(
            $content,
            $input,
            TraceCode::GATEWAY_REFUND_RESPONSE
        );

        $this->createWalletRefundEntity($content, $input);

        if ($content[ResponseFields::STATUS] !== ResponseFields::REFUND_SUCCESS_STATUS)
        {
            $message = isset($content[ResponseFields::MESSAGE]) ? $content[ResponseFields::MESSAGE] : null;

            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_REFUND_FAILED,
                $content[ResponseFields::STATUS],
                $message,
                [
                    Payment\Gateway::GATEWAY_RESPONSE  => json_encode($content),
                    Payment\Gateway::GATEWAY_KEYS      => $this->getGatewayData($content)
                ]);
        }

        return [
            PaymentModel\Gateway::GATEWAY_RESPONSE => json_encode($response->body),
            PaymentModel\Gateway::GATEWAY_KEYS     => $this->getGatewayData($content)
        ];
    }

    public function alreadyRefunded(array $input)
    {
        $paymentId = $input['payment_id'];
        $refundAmount = $input['refund_amount'];
        $refundId = $input['refund_id'];

        $refundedEntities = $this->repo->findSuccessfulRefundByRefundId($refundId, Processor\Wallet::OLAMONEY);

        if ($refundedEntities->count() === 0)
        {
            return false;
        }

        $refundEntity = $refundedEntities->first();

        $refundEntityPaymentId = $refundEntity->getPaymentId();
        $refundEntityRefundAmount = $refundEntity->getAmount();
        $refundEntityStatusCode = $refundEntity->getStatusCode();

        $this->trace->info(
            TraceCode::GATEWAY_ALREADY_REFUNDED_INPUT,
            [
                'input'                 => $input['refund']['id'],
                'refund_payment_id'     => $refundEntityPaymentId,
                'gateway_refund_amount' => $refundEntityRefundAmount,
                'status_code'           => $refundEntityStatusCode,
            ]);

        if (($refundEntityPaymentId !== $paymentId) or
            ($refundEntityRefundAmount !== $refundAmount) or
            ($refundEntityStatusCode !== ResponseFields::REFUND_SUCCESS_STATUS))
        {
            return false;
        }

        return true;
    }

    public function verify(array $input)
    {
        parent::verify($input);

        $verify = new Verify($this->gateway, $input);

        return $this->runPaymentVerifyFlow($verify);
    }

    public function getPaymentIdFromServerCallback(array $input)
    {
        return $input['merchantBillId'];
    }

    public function otpGenerate(array $input)
    {
        $this->action($input, Action::OTP_GENERATE);

        $this->eligibility($input);

        $request = $this->getOtpGenerateRequestArray($input);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_OTP_GENERATE_REQUEST,
            [
                'request' => $request,
                'payment_id' => $input['payment']['id']
            ]);

        $request['headers'] = $this->getRequestHeaders();

        $response = $this->sendGatewayRequest($request);

        // In 1 minute you can hit the RE-SEND-OTP API 4 times.
        // From 5th time within that 1 minute, API will return 429 status code with no content.
        // User can try again, from next minute.
        if ($response->status_code === 429)
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_MAXIMUM_SMS_LIMIT_REACHED);
        }

        $content = $this->parseResponseBody($response);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_OTP_GENERATE_RESPONSE,
            [
                'response' => $content,
                'payment_id' => $input['payment']['id']
            ]);

        $code = $content['status'];

        // Payment fails, throw exception
        if ($code !== Status::SUCCESS)
        {
            $message = $content[ResponseFields::MESSAGE] ?? null;

            $errorCode = ResponseCode::getApiErrorCode($message);

            throw new Exception\GatewayErrorException(
                $errorCode,
                $code,
                $message);
        }

        return $this->getOtpSubmitRequest($input);
    }

    public function callbackOtpSubmit(array $input)
    {
        $this->action($input, Action::OTP_SUBMIT);

        $this->verifyOtpAttempts($input['payment']);

        $request = $this->getOtpSubmitRequestArray($input);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_OTP_SUBMIT_REQUEST,
            [
                'request' => $request,
                'payment_id' => $input['payment']['id']
            ]);

        $request['headers'] = $this->getRequestHeaders();

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $data = [];

        if (isset($content[ResponseFields::ACCESS_TOKEN]) === true)
        {
            $data['token'] = $this->getTokenAttributes($content);

            $content[ResponseFields::ACCESS_TOKEN] = '';
            $content[ResponseFields::REFRESH_TOKEN] = '';
        }

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_OTP_SUBMIT_RESPONSE,
            [
                'content' => $content,
                'payment_id' => $input['payment']['id']
            ]);

        // Payment fails, throw exception
        if (($content[ResponseFields::STATUS] !== Status::SUCCESS) or
            (isset($content[ResponseFields::ACCESS_TOKEN]) === false))
        {
            $message = isset($content[ResponseFields::MESSAGE]) ? $content[ResponseFields::MESSAGE] : null;

            $errorCode = ResponseCode::getApiErrorCode($message);

            throw new Exception\GatewayErrorException(
                $errorCode,
                $content[ResponseFields::STATUS],
                $message);
        }

        $callbackResponse = $this->getCallbackResponseData($input);

        $callbackResponse = array_merge($callbackResponse, $data);

        return $callbackResponse;
    }

    public function checkBalance(array $input)
    {
        $this->action($input, Action::GET_BALANCE);

        $content[RequestFields::USER_ACCESS_TOKEN] = $input['token']['gateway_token'];

        $request = $this->getStandardRequestArray();

        $this->trace->info(
            TraceCode::GATEWAY_CHECK_BALANCE_REQUEST,
            [
                'request' => $request,
                'payment_id' => $input['payment']['id']
            ]);

        $request['headers'] = $this->getRequestHeaders();

        $request['content'] = json_encode($content);

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->trace->info(
            TraceCode::GATEWAY_CHECK_BALANCE_RESPONSE,
            [
                'response' => $content,
                'payment_id' => $input['payment']['id']
            ]);

        $userBalance = 0;

        if (($content[ResponseFields::STATUS] === Status::SUCCESS) and
            (isset($content[ResponseFields::AMOUNT]) === true))
        {
            $userBalance = (int) (($content[ResponseFields::AMOUNT]) * 100);

            $key = $this->getBalanceKeyForCache($input['payment']);

            // Multiplying by 60 since cache put() expect ttl in seconds
            $this->app['cache']->put($key, $userBalance, self::PAYMENT_TTL * 60);
        }

        if ($input['payment']['amount'] > $userBalance)
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_PAYMENT_WALLET_INSUFFICIENT_BALANCE);
        }
    }

    public function topup(array $input)
    {
        return $this->authorize($input);
    }

    public function debit(array $input)
    {
        if ($this->version === 'v2')
        {
            return;
        }

        $this->action($input, Action::DEBIT_WALLET);

        $request = $this->getDebitRequestArray($input);

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_DEBIT_RESPONSE,
            [
                'response' => $content,
                'payment_id' => $input['payment']['id']
            ]);

        if ((isset($content[ResponseFields::STATUS]) === false) or
            ($content[ResponseFields::STATUS] !== Status::SUCCESS))
        {
            $code = null;

            if (isset($content[ResponseFields::MESSAGE]) === true)
            {
                $code = $content[ResponseFields::MESSAGE];
            }
            else if (isset($content[ResponseFields::COMMENTS]) === true)
            {
                $code = $content[ResponseFields::COMMENTS];
            }

            $errorCode = ResponseCode::getApiErrorCode($code);

            throw new Exception\GatewayErrorException($errorCode);
        }

        $this->verifySecureHash($content);

        $expectedAmount = number_format($input['payment']['amount'] / 100, 2, '.', '');

        $actualAmount = number_format((float) $content[ResponseFields::AMOUNT], 2, '.', '');

        $this->assertAmount($expectedAmount, $actualAmount);

        $gatewayPaymentAttrs = $this->getCreateWalletAttributes($input, $content);

        $this->createGatewayPaymentEntity($gatewayPaymentAttrs, Action::AUTHORIZE);
    }

    public function verifyRefund(array $input)
    {
        parent::verify($input);

        $scroogeResponse = new GatewayBase\ScroogeResponse();

        $content = $this->sendRefundVerifyRequest($input);

        $scroogeResponse->setGatewayVerifyResponse(json_encode($content))
                        ->setGatewayKeys($this->getGatewayData($content));

        if ($content[ResponseFields::STATUS] === Status::COMPLETED)
        {
            return $scroogeResponse->setSuccess(true)
                                   ->toArray();
        }
        else if ($content[ResponseFields::STATUS] === Status::ERROR)
        {
            return $scroogeResponse->setSuccess(false)
                                   ->setStatusCode(ErrorCode::GATEWAY_VERIFY_REFUND_ABSENT)
                                   ->toArray();
        }

        throw new Exception\LogicException(
            'Unrecognized verify refund status',
            ErrorCode::GATEWAY_ERROR_UNEXPECTED_STATUS,
            [
                PaymentModel\Gateway::GATEWAY_VERIFY_RESPONSE  => json_encode($content),
                PaymentModel\Gateway::GATEWAY_KEYS             => [
                'status'     => $content[ResponseFields::STATUS],
                'payment_id' => $input['refund']['payment_id'],
                'refund_id'  => $input['refund']['id'],
            ]]);
    }

    protected function getEligibilityRequest(array $input)
    {
        $amount       = number_format($input['payment']['amount'] / 100, 2, '.', '');
        $contact      = $this->getFormattedContact($input['payment']['contact']);
        $billingLabel = $this->getDynamicMerchantName($input['merchant']);

        $hashFields = [
            RequestFields::MOBILE                   =>  $contact,
            RequestFields::EMAIL                    =>  'NA',
            RequestFields::FIRST_NAME               =>  'NA',
            RequestFields::LAST_NAME                =>  'NA',
            RequestFields::AMOUNT                   =>  $amount,
            RequestFields::SOURCE                   =>  $billingLabel,
            RequestFields::UNIQUE_ELIGIBILITY_ID    =>  $input['payment']['id'],
        ];

        $hashValue = $this->getHashForEligibility($hashFields);

        $userInfo = [
            RequestFields::MOBILE_NUMBER    => $contact,
            RequestFields::EMAIL            => 'NA',
            RequestFields::FIRST_NAME       => 'NA',
            RequestFields::LAST_NAME        => 'NA',
        ];

        $transactionDetails = [
            RequestFields::AMOUNT       => $amount,
            RequestFields::DENOMINATION => 'rupee',
            RequestFields::CURRENCY     => $input['payment']['currency'],
        ];

        $queryArray = [
            RequestFields::USER_INFO             => $userInfo,
            RequestFields::TRANSACTION_DETAILS   => $transactionDetails,
            RequestFields::SOURCE                => $billingLabel,
            RequestFields::HASH                  => $hashValue,
            RequestFields::UNIQUE_ELIGIBILITY_ID => $input['payment']['id'],
        ];

        $content = json_encode($queryArray);

        $request = $this->getStandardRequestArray($content,'post', "ELIGIBILITY");

        $request['headers'] = $this->getRequestHeaders();

        return $request;
    }

    protected function getDebitRequestArray(array $input)
    {
        $content = $this->getDebitRequestAttributes($input);

        $traceContent = $content;

        $request = $this->getStandardRequestArray();

        $traceContent[RequestFields::ACCESS_TOKEN] = '';
        $traceContent[RequestFields::HASH] = '';

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_DEBIT_REQUEST,
            [
                'request' => $request,
                'content' => $traceContent
            ]);

        $request['headers'] = $this->getRequestHeaders();

        $request['content'] = json_encode($content);

        return $request;
    }

    protected function getDebitRequestAttributes(array $input)
    {
        $amount = number_format($input['payment']['amount'] / 100, 2, '.', '');

        $udf = [RequestFields::MERCHANT_DISPLAY_NAME => $input['merchant']->getFilteredDba()];
        $udf = json_encode($udf);

        $notificationUrl = $this->route->getUrlWithPublicAuth(
                                'gateway_payment_callback_post',
                                ['gateway' => 'wallet_olamoney']);

        $content = [
            RequestFields::COMMAND              => Command::DEBIT,
            RequestFields::ACCESS_TOKEN         => $this->getAccessToken($input['terminal']),
            RequestFields::UNIQUE_ID            => $input['payment']['id'],
            RequestFields::COMMENTS             => $input['payment']['public_id'],
            RequestFields::UDF                  => $udf,
            RequestFields::RETURN_URL           => 'NA',
            RequestFields::NOTIFICATION_URL     => $notificationUrl,
            RequestFields::AMOUNT               => $amount,
            RequestFields::CURRENCY             => $input['payment']['currency'],
            RequestFields::COUPON_CODE          => 'NA',
            RequestFields::USER_ACCESS_TOKEN    => $input['token']['gateway_token'],
        ];

        $content[RequestFields::HASH] = $this->getHashForDebit($content);

        return $content;
    }

    protected function callbackTopupFlow(array $input)
    {
        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_TOPUP_CALLBACK,
            [
                'request'       => $input['gateway'],
                'gateway'       => $this->gateway,
                'payment_id'    => $input['payment']['id'],
            ]);

        $content = $input['gateway'];

        $responseStatus = isset($content['status']) ? $content['status'] : null;

        if ($responseStatus !== Status::SUCCESS)
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_PAYMENT_FAILED, $responseStatus);
        }

        return [];
    }

    protected function getCreateWalletAttributes(array $input, array $content)
    {
        $contentToSave = [
            ResponseFields::AMOUNT          => $input['payment']['amount'],
            Entity::RECEIVED                => true,
            Entity::EMAIL                   => $input['payment']['email'],
            Entity::CONTACT                 => $this->getFormattedContact($input['payment']['contact']),
            ResponseFields::STATUS          => $content[ResponseFields::STATUS],
            ResponseFields::TRANSACTION_ID  => $content[ResponseFields::TRANSACTION_ID],
        ];

        return $contentToSave;
    }

    protected function verifyPaymentCallbackResponse(array $input)
    {
        $content = $input['gateway'];

        if ($content[ResponseFields::STATUS] !== Status::SUCCESS)
        {
            $message = isset($content[ResponseFields::MESSAGE]) ? $content[ResponseFields::MESSAGE] : null;

            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_PAYMENT_FAILED,
                $content[ResponseFields::STATUS],
                $message);
        }
    }

    protected function verifySecureHash(array $content)
    {
        $fieldsInOrder = [
            ResponseFields::TYPE,
            ResponseFields::STATUS,
            ResponseFields::MERCHANT_BILL_ID,
            ResponseFields::TRANSACTION_ID,
            ResponseFields::AMOUNT,
            ResponseFields::COMMENTS,
            ResponseFields::UDF,
            ResponseFields::IS_CASHBACK_ATTEMPTED,
            ResponseFields::IS_CASHBACK_SUCCESSFUL,
            ResponseFields::TIMESTAMP,
        ];

        if ($this->version === 'v2')
        {
            $fieldsInOrder[] = ResponseFields::SALT;
        }

        $actual = $content[ResponseFields::HASH];

        $content = $this->getDataWithFieldsInOrder($content, $fieldsInOrder);

        $generated = $this->getHashOfArray($content);

        $this->compareHashes($actual, $generated);
    }

    protected function getBillGeneratorRequest(array $input)
    {
        $content = $this->getBillGeneratorAttributes($input);

        $requestContent = [
            RequestFields::BILL => base64_encode(json_encode($content)),
            RequestFields::PHONE => $this->getFormattedContact($input['payment']['contact'])
        ];

        $request = $this->getStandardRequestArray([], 'get');

        $content[RequestFields::USER_ACCESS_TOKEN] = '';
        $content[RequestFields::ACCESS_TOKEN] = '';
        $content[RequestFields::HASH] = '';

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_TOPUP_REQUEST,
            [
                'request' => $request,
                'content' => $content
            ]);

        $query = http_build_query($requestContent);

        $request['url'] = $request['url'] . '?' . $query;

        return $request;
    }

    protected function getAuthorizeRequestDataV2(array $input)
    {
        $udf = [RequestFields::MERCHANT_DISPLAY_NAME => $input['merchant']->getFilteredDba()];
        $udf = json_encode($udf);

        $notificationUrl = $this->route->getUrlWithPublicAuth(
                                'gateway_payment_callback_post',
                                ['gateway' => 'wallet_olamoney']);

        $content = [
            RequestFields::ACCESS_TOKEN         => $this->getAccessToken($input['terminal']),
            RequestFields::UNIQUE_ID            => $input[ConstantEntity::PAYMENT]['id'],
            RequestFields::COMMENTS             => 'Razorpay_payment',
            RequestFields::UDF                  => $udf,
            RequestFields::RETURN_URL           => $input['callbackUrl'],
            RequestFields::NOTIFICATION_URL     => $notificationUrl,
            RequestFields::CURRENCY             => $input['payment']['currency'],
            RequestFields::AMOUNT               => $this->getFormattedAmount($input[ConstantEntity::PAYMENT]['amount']),
            RequestFields::COUPON_CODE          => 'NA',
            RequestFields::BALANCE_PREFERENCE   => 'preferConfig',
        ];

        $content[RequestFields::HASH] = $this->getHashForDebit($content);

        $content[RequestFields::COMMAND]                  = Command::DEBIT;
        $content[RequestFields::USER_ACCESS_TOKEN]        = $input['token']['gateway_token'];
        $content[RequestFields::MOBILE]                   = $this->getFormattedContact($input['payment']['contact']);
        $content[RequestFields::EMAIL]                    = $input['payment']['email'];
        $content[RequestFields::LINK_NOTIFICATION_URL]    = $notificationUrl;
        $content[RequestFields::SIGNATURE]                = $this->getSignature($input[ConstantEntity::PAYMENT]['id']);

        return $content;
    }

    protected function getBillGeneratorAttributes(array $input)
    {
        $key = $this->getBalanceKeyForCache($input['payment']);

        // Wallet Balance is in paise
        $walletBalance = $this->app['cache']->get($key, 0);

        $topupAmount = ($input['payment']['amount'] - $walletBalance);

        $formattedAmount = number_format($topupAmount / 100, 2, '.', '');

        $udf = [RequestFields::MERCHANT_DISPLAY_NAME => $input['merchant']->getFilteredDba()];
        $udf = json_encode($udf);

        $content = [
            RequestFields::COMMAND                  => Command::CREDIT,
            RequestFields::ACCESS_TOKEN             => $this->getAccessToken($input['terminal']),
            RequestFields::MERCHANT_REFERENCE_ID    => $input['payment']['id'],
            RequestFields::COMMENTS                 => 'Razorpay_payment',
            RequestFields::UDF                      => $udf,
            RequestFields::RETURN_URL               => $input['callbackUrl'],
            RequestFields::NOTIFICATION_URL         => 'NA',
            RequestFields::AMOUNT                   => $formattedAmount,
            RequestFields::USER_ACCESS_TOKEN        => $input['token']['gateway_token'],
            RequestFields::CURRENCY                 => $input['payment']['currency'],
            RequestFields::BALANCE_TYPE             => 'cash',
            RequestFields::BALANCE_NAME             => 'cash',
        ];

        $content[RequestFields::HASH] = $this->getHashForBill($content);

        return $content;
    }

    protected function getCreateWalletAttributesV2(array $input)
    {
        $attributes = [
            Base\Entity::AMOUNT         => $input[ConstantEntity::PAYMENT][Payment\Entity::AMOUNT],
            Base\Entity::EMAIL          => $input[ConstantEntity::PAYMENT][Payment\Entity::EMAIL],
            Base\Entity::CONTACT        => $input[ConstantEntity::PAYMENT][Payment\Entity::CONTACT],
            Base\Entity::MERCHANT_ID    => $input[ConstantEntity::PAYMENT][Payment\Entity::MERCHANT_ID],
            Base\Entity::PAYMENT_ID     => $input[ConstantEntity::PAYMENT][Payment\Entity::ID],
        ];

        return $attributes;
    }

    protected function callbackAuthSuccessFlow(array $input, array $content)
    {
        $contentToSave = [
            ResponseFields::AMOUNT          => $input['payment']['amount'],
            Entity::RECEIVED                => true,
            Entity::EMAIL                   => $input['payment']['email'],
            Entity::CONTACT                 => $this->getFormattedContact($input['payment']['contact']),
            ResponseFields::STATUS          => $content[ResponseFields::STATUS],
            ResponseFields::TRANSACTION_ID  => $content[ResponseFields::TRANSACTION_ID],
        ];

        $wallet = $this->repo->findByPaymentIdAndAction($input['payment']['id'], Action::AUTHORIZE);

        $this->updateGatewayPaymentEntity($wallet, $contentToSave);
    }

    protected function getOtpGenerateRequestArray(array $input)
    {
        $payment = $input['payment'];

        $queryArray = [
            RequestFields::PHONE    => $this->getFormattedContact($payment['contact']),
            RequestFields::EMAIL    => $payment['email'],
        ];

        $request = $this->getStandardRequestArray($queryArray);

        $query = http_build_query($queryArray);

        $request['url'] = $request['url'] . '?' . $query;

        return $request;
    }

    protected function getOtpSubmitRequestArray(array $input)
    {
        $payment = $input['payment'];

        $queryArray = [
            RequestFields::PHONE    => $this->getFormattedContact($payment['contact']),
            RequestFields::OTP      => $input['gateway']['otp'],
        ];

        $request = $this->getStandardRequestArray($queryArray);

        $query = http_build_query($queryArray);

        $request['url'] = $request['url'] . '?' . $query;

        return $request;
    }

    protected function verifyPayment($verify)
    {
        // api wallet gateway entity
        $gatewayPayment = $verify->payment;

        $input = $verify->input;

        // Gateway response from verify_payment
        // Possible $verifyResponse status values - completed, failed, initialized, error
        $verifyResponse = $verify->verifyResponseContent;

        $verify->status = VerifyResult::STATUS_MATCH;

        if ($verifyResponse[ResponseFields::STATUS] === Status::COMPLETED)
        {
            $this->checkVerifyStatusOnGatewaySuccess($gatewayPayment, $input, $verify);
        }
        else
        {
            $this->checkVerifyStatusOnGatewayFail($gatewayPayment, $input, $verify);
        }

        $verify->match = ($verify->status === VerifyResult::STATUS_MATCH) ? true : false;

        $verify->payment = $this->saveVerifyContent($gatewayPayment, $verify);

        return $verify->status;
    }

    protected function checkVerifyStatusOnGatewayFail($gatewayPayment, array $input, $verify)
    {
        $verify->gatewaySuccess = false;

        $verifyResponse = $verify->verifyResponseContent;

        if (in_array($verifyResponse[ResponseFields::STATUS], ResponseFields::VERIFY_FAILED_STATUS))
        {
            // If payment is marked as success in api or in gateway entity,
            // but gateway's verify response returned false. This is an issue
            // and should ideally never happen.
            if ((($input['payment']['status'] !== PaymentStatus::FAILED) and
                 ($input['payment']['status'] !== PaymentStatus::CREATED)) or
                (($gatewayPayment !== null) and ($gatewayPayment['status_code'] === Status::SUCCESS)))
            {
                // Ideally both api payment entity status and gateway payment
                // entity status should be true, to reach this block. In case
                // even if one of them is not true, we log it.
                if (($input['payment']['status'] === PaymentStatus::FAILED) or
                    ($input['payment']['status'] === PaymentStatus::CREATED) or
                    (($gatewayPayment === null) or ($gatewayPayment['status_code'] !== Status::SUCCESS)))
                {
                    $this->trace->info(
                        TraceCode::GATEWAY_PAYMENT_VERIFY_UNEXPECTED,
                        [
                            'api_payment_status'      => $input['payment']['status'],
                            'gateway_verify_response' => $verifyResponse,
                            'payment_id'              => $input['payment']['id'],
                            'gateway_payment_status'  => $gatewayPayment['status_code'],
                        ]);
                }

                $verify->apiSuccess = true;

                $verify->status = VerifyResult::STATUS_MISMATCH;
            }
            else
            {
                $verify->apiSuccess = false;
            }
        }
    }

    protected function checkVerifyStatusOnGatewaySuccess($gatewayPayment, array $input, $verify)
    {
        $verify->gatewaySuccess = true;

        $verifyResponse = $verify->verifyResponseContent;

        // $input['payment'] is api payment entity
        if (($input['payment']['status'] !== PaymentStatus::CREATED) and
            ($input['payment']['status'] !== PaymentStatus::FAILED) and
            ($gatewayPayment !== null) and
            ($gatewayPayment['status_code'] === Status::SUCCESS))
        {
            $verify->apiSuccess = true;
        }
        // api's payment entity could be in either authorized or captured state
        // and gateway's payment entity is either null or its status is failed.
        // This is an issue, and should ideally never happen.
        else if (($input['payment']['status'] !== PaymentStatus::CREATED) and
                 ($input['payment']['status'] !== PaymentStatus::FAILED) and
                 (($gatewayPayment === null) or
                  ($gatewayPayment['status_code'] !== Status::SUCCESS)))
        {
            $gatewayPaymentStatus = isset($gatewayPayment) ? $gatewayPayment['status_code'] : '';

            $this->trace->info(
                    TraceCode::GATEWAY_PAYMENT_VERIFY_UNEXPECTED,
                    [
                        'api_payment_status'      => $input['payment']['status'],
                        'gateway_verify_response' => $verifyResponse[ResponseFields::STATUS],
                        'payment_id'              => $input['payment']['id'],
                        'gateway_payment_status'  => $gatewayPaymentStatus,
                    ]);

            $verify->apiSuccess = true;
        }
        else
        {
            $verify->status = VerifyResult::STATUS_MISMATCH;

            $verify->apiSuccess = false;
        }
    }

    protected function saveVerifyContent($gatewayPayment, $verify)
    {
        $this->action = Action::AUTHORIZE;

        $verifyResponse = $verify->verifyResponseContent;

        if ($verify->gatewaySuccess === true)
        {
            $walletAttributes = $this->getVerifyWalletCreateAttributes($verifyResponse);

            $walletMappedAttributes = $this->getMappedAttributes($walletAttributes);

            if ($gatewayPayment === null)
            {
                $gatewayPayment = $this->createGatewayPaymentEntity($walletAttributes);
            }
            else if (($gatewayPayment['received'] === false) or
                     ($gatewayPayment['status_code'] !== Status::SUCCESS))
            {
                $gatewayPayment->fill($walletMappedAttributes);
                $gatewayPayment->saveOrFail();
            }
        }

        $this->action = Action::VERIFY;

        return $gatewayPayment;
    }

    protected function getVerifyWalletCreateAttributes(array $verifyResponse)
    {
        $payment = $this->input['payment'];

        $contentToSave = [
            ResponseFields::AMOUNT          => $payment['amount'],
            Entity::RECEIVED                => true,
            Entity::EMAIL                   => $payment['email'],
            Entity::CONTACT                 => $this->getFormattedContact($payment['contact']),
            ResponseFields::STATUS          => Status::SUCCESS,
            ResponseFields::TRANSACTION_ID  => $verifyResponse[ResponseFields::GLOBAL_MERCHANT_ID],
        ];

        return $contentToSave;
    }

    protected function sendPaymentVerifyRequest($verify)
    {
        $input = $verify->input;

        $request = $this->getVerifyRequestArray($input, 'payment');

        $this->trace->info(TraceCode::GATEWAY_PAYMENT_VERIFY_REQUEST, $request);

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_VERIFY_RESPONSE,
            [
                'content' => $content,
                'gateway' => 'wallet_olamoney',
                'payment_id' => $input['payment']['id'],
            ]);

        $verify->verifyResponse = $response;

        $verify->verifyResponseBody = $response->body;

        $verify->verifyResponseContent = $content;

        return $content;
    }

    protected function sendRefundVerifyRequest(array $input)
    {
        $request = $this->getVerifyRequestArray($input, 'refund');

        $this->traceGatewayPaymentRequest(
            $request,
            $input,
            TraceCode::GATEWAY_REFUND_VERIFY_REQUEST);

        $response = $this->sendGatewayRequest($request);

        $content = $this->parseResponseBody($response);

        $this->traceGatewayPaymentResponse(
            $content,
            $input,
            TraceCode::GATEWAY_REFUND_VERIFY_RESPONSE);

        return $content;
    }

    protected function getVerifyRequestArray(array $input, string $entity)
    {
        $content = [
            RequestFields::UNIQUE_BILL_ID   => $input[$entity]['id'],
            RequestFields::ACCESS_TOKEN     => $this->getAccessToken($input['terminal']),
            RequestFields::TIMESTAMP        => Carbon::now(Timezone::IST)->format('Y-m-d H:i:s'),
        ];

        $content[RequestFields::HASH] = $this->getHashForVerifyRequest($content);

        $request = $this->getStandardRequestArray($content, 'GET');

        return $request;
    }

    protected function getHashForVerifyRequest(array $content)
    {
        $str = $content[RequestFields::ACCESS_TOKEN] . '|';
        $str .= $content[RequestFields::UNIQUE_BILL_ID] . '||';
        $str .= $content[RequestFields::TIMESTAMP] . '|||';
        $str .= $this->getSecret();

        return $this->getHashOfString($str);
    }

    protected function shouldReturnIfPaymentNullInVerifyFlow($verify)
    {
        return false;
    }

    protected function createWalletRefundEntity(array $content, array $input)
    {
        $refundAttributes = $this->getRefundEntityAttributesFromRefundResponse($content, $input);

        return $this->createGatewayRefundEntity($refundAttributes);
    }

    protected function getRefundEntityAttributesFromRefundResponse(array $content, array $input)
    {
        $gatewayRefundId = null;

        if (isset($content[ResponseFields::TRANSACTION_ID]) === true)
        {
            $gatewayRefundId = $content[ResponseFields::TRANSACTION_ID];
        }

        $responseCode = isset($content[ResponseFields::ERROR_CODE]) ? $content[ResponseFields::ERROR_CODE] : null;

        $errorMessage = isset($content[ResponseFields::MESSAGE]) ? $content[ResponseFields::MESSAGE] : null;

        $refundAttributes = [
            Entity::PAYMENT_ID              => $input['payment']['id'],
            Entity::ACTION                  => $this->action,
            Entity::AMOUNT                  => $input['refund']['amount'],
            Entity::RECEIVED                => 1,
            Entity::WALLET                  => $input['payment']['wallet'],
            Entity::EMAIL                   => $input['payment']['email'],
            Entity::CONTACT                 => $input['payment']['contact'],
            Entity::GATEWAY_REFUND_ID       => $gatewayRefundId,
            Entity::REFUND_ID               => $input['refund']['id'],
            Entity::RESPONSE_CODE           => $responseCode,
            Entity::STATUS_CODE             => $content[ResponseFields::STATUS],
            Entity::ERROR_MESSAGE           => $errorMessage,
        ];

        return $refundAttributes;
    }

    protected function getRefundRequest($input): array
    {
        $content = [
            RequestFields::COMMAND          => Command::REFUND,
            RequestFields::ACCESS_TOKEN     => $this->getAccessToken($input['terminal']),
            RequestFields::UNIQUE_ID        => $this->getRefundId($input['refund']),
            RequestFields::COMMENTS         => 'Razorpay_refund',
            RequestFields::UDF              => $input['payment']['public_id'],
            RequestFields::RETURN_URL       => 'NA',
            RequestFields::NOTIFICATION_URL => 'NA',
            RequestFields::AMOUNT           => (string) number_format($input['refund']['amount'] / 100, 2, '.', ''),
            RequestFields::BALANCE_TYPE     => 'cash',
            RequestFields::BALANCE_NAME     => 'cash',
            RequestFields::SALE_ID          => $input['payment']['id'],
            RequestFields::CURRENCY         => $input['payment']['currency'],
        ];

        // Changes for olamoney postpaid
        $type = null;

        if ($this->version === 'v2')
        {
            $type = 'refund_v3';

            unset($content[RequestFields::SALE_ID]);

            $gatewayPayment = $this->repo->findByPaymentIdAndActionOrFail(
                $input['payment']['id'],
                Action::AUTHORIZE);

            $content[RequestFields::SALE_ID_V2] = $gatewayPayment->getGatewayPaymentId();
        }

        $content[RequestFields::HASH] = $this->getHashForRefundRequest($content);

        $request = $this->getStandardRequestArray(json_encode($content), 'post', $type);

        return $request;
    }

    protected function getHashForRefundRequest(array $content)
    {
        $fieldsInOrder = [
            RequestFields::ACCESS_TOKEN,
            RequestFields::UNIQUE_ID,
            RequestFields::COMMENTS,
            RequestFields::UDF,
            RequestFields::RETURN_URL,
            RequestFields::NOTIFICATION_URL,
            RequestFields::CURRENCY,
            RequestFields::AMOUNT,
            RequestFields::BALANCE_TYPE,
            RequestFields::BALANCE_NAME,
            RequestFields::SALE_ID,
            RequestFields::SALE_ID_V2,
        ];

        $orderedData = $this->getDataWithFieldsInOrder($content, $fieldsInOrder);

        return $this->getHashOfArray($orderedData);
    }

    protected function getAccessToken($terminal)
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_access_code'];
        }

        return $terminal['gateway_access_code'];
    }

    protected function getHashForDebit(array $content)
    {
        $fieldsInOrder = [
            RequestFields::ACCESS_TOKEN,
            RequestFields::UNIQUE_ID,
            RequestFields::COMMENTS,
            RequestFields::UDF,
            RequestFields::RETURN_URL,
            RequestFields::NOTIFICATION_URL,
            RequestFields::CURRENCY,
            RequestFields::AMOUNT,
            RequestFields::USER_ACCESS_TOKEN,
            RequestFields::COUPON_CODE,
        ];

        if ($this->version === 'v2')
        {
            $fieldsInOrder[] = RequestFields::BALANCE_PREFERENCE;
        }

        $orderedData = $this->getDataWithFieldsInOrder($content, $fieldsInOrder);

        return $this->getHashOfArray($orderedData);
    }

    protected function getHashForBill(array $content)
    {
        $fieldsInOrder = [
            RequestFields::ACCESS_TOKEN,
            RequestFields::MERCHANT_REFERENCE_ID,
            RequestFields::COMMENTS,
            RequestFields::UDF,
            RequestFields::RETURN_URL,
            RequestFields::NOTIFICATION_URL,
            RequestFields::CURRENCY,
            RequestFields::AMOUNT,
            RequestFields::USER_ACCESS_TOKEN,
        ];

        $orderedData = $this->getDataWithFieldsInOrder($content, $fieldsInOrder);

        return $this->getHashOfArray($orderedData);
    }

    protected function getHashForEligibility(array $content)
    {
        $fieldsInOrder = [
            RequestFields::MOBILE,
            RequestFields::EMAIL,
            RequestFields::FIRST_NAME,
            RequestFields::LAST_NAME,
            RequestFields::AMOUNT,
            RequestFields::SOURCE,
            RequestFields::UNIQUE_ELIGIBILITY_ID,
        ];

        $orderedData = $this->getDataWithFieldsInOrder($content, $fieldsInOrder);

        return $this->getHashOfArray($orderedData);
    }

    protected function getHashOfArray($content)
    {
        $str = $this->getStringToHash($content, '|');

        $str .= '|' . $this->getSecret();

        return $this->getHashOfString($str);
    }

    protected function getHashOfString($str)
    {
        return strtolower(hash(HashAlgo::SHA512, $str));
    }

    protected function getRelativeUrl($type)
    {
        $ns = $this->getGatewayNamespace();

        $url = constant($ns.'\Url::'.$type);

        $contact = $this->input['payment']['contact'];

        return strtr($url, [':contact' => $this->getFormattedContact($contact)]);
    }

    protected function getRequestHeaders(): array
    {
        return [
            'Content-Type'  => 'application/json',
            'Authorization' => 'Basic '. $this->getBasicAuthToken()
        ];
    }

    protected function getBasicAuthToken()
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_merchant_id'];
        }

        return $this->input['terminal']['gateway_terminal_password'];
    }

    protected function getValidWalletToken(array $input)
    {
        $token = (new Token\Repository)
                        ->getByWalletTerminalAndCustomerId(
                            $input['payment']['wallet'],
                            $input['terminal']['id'],
                            $input['customer']['id']);

        if (($token !== null) and ($token->getExpiredAt() > time()))
        {
            return $token;
        }
    }

    protected function getTokenAttributes(array $content)
    {
        $input = $this->input;

        $attributes = [
            Token\Entity::METHOD           => 'wallet',
            Token\Entity::WALLET           => $input['payment']['wallet'],
            Token\Entity::TERMINAL_ID      => $input['terminal']['id'],
            Token\Entity::GATEWAY_TOKEN    => $content[ResponseFields::ACCESS_TOKEN],
            Token\Entity::GATEWAY_TOKEN2   => $content[ResponseFields::REFRESH_TOKEN],
            Token\Entity::EXPIRED_AT       => time() + self::WALLET_ACCESS_TOKEN_EXPIRY,
        ];

        return $attributes;
    }

    protected function parseResponseBody($response)
    {
        if ($response->body === '')
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::GATEWAY_ERROR_FATAL_ERROR,
                '',
                'Invalid JSON in Response Body',
                ['Invalid JSON in Response Body']);
        }

        $content = $this->jsonToArray($response->body);

        return $content;
    }

    protected function getBalanceKeyForCache($payment)
    {
        return sprintf(self::BALANCE_CACHE_KEY, $payment['id']);
    }

    protected function getGatewayData(array $refundFields = [])
    {
        if (empty($refundFields) === false)
        {
            return [
                ResponseFields::TYPE             => $refundFields[ResponseFields::TYPE] ?? null,
                ResponseFields::STATUS           => $refundFields[ResponseFields::STATUS] ?? null,
                ResponseFields::COMMENTS         => $refundFields[ResponseFields::COMMENTS] ?? null,
                ResponseFields::TIMESTAMP        => $refundFields[ResponseFields::TIMESTAMP] ?? null,
                ResponseFields::TRANSACTION_ID   => $refundFields[ResponseFields::TRANSACTION_ID] ?? null,
                ResponseFields::UNIQUE_BILL_ID   => $refundFields[ResponseFields::UNIQUE_BILL_ID] ?? null,
            ];
        }
        return [];
    }

    public function getSignature($id)
    {
        $privateKey = $this->getPrivateKey();

        $rsa = new RSA();

        $rsa->setPrivateKeyFormat(RSA::PRIVATE_FORMAT_PKCS8);
        $rsa->loadKey(base64_decode($privateKey), RSA::PRIVATE_FORMAT_PKCS8);

        $rsa->setSignatureMode(RSA::SIGNATURE_PKCS1);

        return base64_encode($rsa->sign(base64_decode($id)));
    }

    public function validateSignature($plaintext, $signature)
    {
        //xtenantKey, xauthKey
        $olaPublicKey = $this->getOlaPublicKey();

        $rsa = new RSA();

        $rsa->setPublicKeyFormat(RSA::PUBLIC_FORMAT_PKCS8);
        $rsa->loadKey(base64_decode($olaPublicKey));

        $rsa->setSignatureMode(RSA::SIGNATURE_PKCS1);

        return $rsa->verify(base64_decode($plaintext),base64_decode($signature));
    }

    public function callbackDebitFlow(array $input)
    {
        $gatewayData = $input['gateway'];

        if (isset($gatewayData['errorCode']) === true)
        {
            $code = $gatewayData['errorCode'];
            $errorCode = ResponseCode::getApiErrorCode($code);

            throw new Exception\GatewayErrorException($errorCode);
        }

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_ENCRYPTED_DEBIT_RESPONSE,
            [
                'response' => $gatewayData,
            ]);

        $body = $gatewayData['body'];
        $encryptedTenantKey = $gatewayData['xtenantKey'];
        $xauthKey = $gatewayData['xauthKey'];

        //Signature Verification
        if ($this->validateSignature($encryptedTenantKey, $xauthKey) === false)
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::GATEWAY_ERROR_SIGNATURE_VALIDATION_FAILED);
        }

        $tenantKey = $this->decryptTenantKey($encryptedTenantKey);

        list($uuid, $timestamp) = explode(':', $tenantKey);

        //Check for timestamp is less than current timestamp
        if (intdiv($timestamp, 1000000) > time())
        {
            throw new Exception\GatewayErrorException(
                ErrorCode::BAD_REQUEST_PAYMENT_TIMED_OUT);
        }

        $response = $this->decryptResponseBody($body, $uuid);

        $content = $this->jsonToArray($response);

        $this->trace->info(
            TraceCode::GATEWAY_PAYMENT_DEBIT_RESPONSE,
            [
                'response' => $content,
                'payment_id' => $content['merchantBillId']
            ]);

        if ((isset($content[ResponseFields::STATUS]) === false) or
            ($content[ResponseFields::STATUS] !== Status::SUCCESS))
        {
            $code = null;

            if (isset($content[ResponseFields::MESSAGE]) === true)
            {
                $code = $content[ResponseFields::MESSAGE];
            }
            else if (isset($content[ResponseFields::COMMENTS]) === true)
            {
                $code = $content[ResponseFields::COMMENTS];
            }

            $errorCode = ResponseCode::getApiErrorCode($code);

            throw new Exception\GatewayErrorException($errorCode);
        }

        $this->verifySecureHash($content);

        $expectedAmount = number_format($input['payment']['amount'] / 100, 2, '.', '');
        $actualAmount = number_format((float) $content[ResponseFields::AMOUNT], 2, '.', '');

        $this->assertAmount($expectedAmount, $actualAmount);

        $this->callbackAuthSuccessFlow($input,$content);

        return $this->getCallbackResponseData($input);
    }

    protected function decryptTenantKey($encryptedTenantKey)
    {
        $privateKey = $this->getPrivateKey();

        $rsa = new RSA();

        $rsa->setPrivateKeyFormat(RSA::PRIVATE_FORMAT_PKCS8);

        $rsa->loadKey(base64_decode($privateKey), RSA::PRIVATE_FORMAT_PKCS8);

        $rsa->setEncryptionMode(RSA::ENCRYPTION_PKCS1);

        return $rsa->decrypt(base64_decode($encryptedTenantKey));
    }

    protected function decryptResponseBody($body, $uuid)
    {
        $getIvParamFromConfig = $this->getIV();

        $cipher = new AES();

        $cipher->setKey($uuid);

        $cipher->setIV($getIvParamFromConfig);

        return ($cipher->decrypt(base64_decode($body)));
    }

    protected function getFormattedAmount($amount)
    {
        return number_format($amount / 100, 2, '.', '');
    }

    public function getPrivateKey()
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_private_key'];
        }

        if ($this->input['terminal']['gateway_merchant_id'] === 'SfTgUl9XYRvb0m2FL5q5')
        {
            return $this->config['live_private_key'];
        }

        return $this->getLiveTerminalPassword2();
    }

    public function getOlaPublicKey()
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_ola_public_key'];
        }

        if ($this->input['terminal']['gateway_merchant_id'] === 'SfTgUl9XYRvb0m2FL5q5')
        {
            return $this->config['live_ola_public_key'];
        }

        return $this->getLiveSecret2();
    }

    public function getPublicKey()
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_public_key'];
        }

        return $this->config['live_public_key'];
    }

    public function getIV()
    {
        if ($this->mode === Mode::TEST)
        {
            return $this->config['test_iv'];
        }

        return $this->config['live_iv'];
    }

    protected function getRefundId(array $refund): string
    {
        return $refund['id'] . ($refund['attempts'] ?: '');
    }
}
