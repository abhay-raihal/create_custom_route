<?php

namespace RZP\Models\Merchant\OneClickCheckout\Shopify;

use App;
use Throwable;
use RZP\Trace\TraceCode;
use RZP\Models\Base;
use RZP\Models\Merchant\Metric;
use RZP\Models\Merchant\OneClickCheckout;
use RZP\Models\Merchant\OneClickCheckout\AuthConfig;

class Coupons extends Base\Core
{

    const COUPON_PLUGINS = [
        'Klaviyo',
    ];

    const SHOPIFY_CHECKOUT_USER_ERROR_CODES_DUE_TO_USER_INPUT = [
        'DISCOUNT_NOT_FOUND',
        'HIGHER_VALUE_DISCOUNT_APPLIED', // TODO: Needs more product understanding.
        'DISCOUNT_LIMIT_REACHED',
        'CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE',
    ];

    const APPLY_COUPON_API_ERROR               = 'apply_coupon_api_error';
    const APPLY_COUPON_NOT_APPLICABLE          = 'apply_coupon_not_applicable';
    const APPLY_COUPON_API_CHECKOUT_USER_ERROR = 'apply_coupon_api_checkout_user_error';

    protected $monitoring;

    public function __construct()
    {
        parent::__construct();

        $this->monitoring = new Monitoring();
    }

    public function getCoupons(array $input): array
    {
        $client = $this->getShopifyClientByMerchant();

        $mutation = (new Mutations)->getCouponListMutation();

        $graphqlQuery = ['query' => $mutation];

        $response = json_decode($client->sendGraphqlRequest(json_encode($graphqlQuery)), true);

        if (empty($response['errors']) !== true)
        {
          $this->trace->error(
               TraceCode::SHOPIFY_1CC_API_COUPONS_ERROR,
               [
                   'type'     => 'invalid_checkout_id',
                   'input'    => $input,
                   'response' => $response,
               ]);

            $this->monitoring->addTraceCount(Metric::SHOPIFY_COUPON_FETCH_ERROR_COUNT, ['error_type' => 'invalid_checkout_id']);

            return ['promotions' => []];
        }

        $orderQuantity = $input['order_quantity'];

        $amount = $input['amount'];

        $discounts = $response['data']['priceRules']['edges'];

        $promotions = [];

        foreach ($discounts as $value)
        {
            $value = $value['node'];
            $discountMinAmount = isset($value['prerequisiteSubtotalRange']['greaterThanOrEqualTo']) ? floatval($value['prerequisiteSubtotalRange']['greaterThanOrEqualTo']) : 0;
            $minQuantityRange = isset($value['prerequisiteQuantityRange']['greaterThanOrEqualTo']) ? floatval($value['prerequisiteQuantityRange']['greaterThanOrEqualTo']) : 0;
            $discountStartDate = $value['startsAt'];
            $dicountEndDate = $value['endsAt'];

            // It hides all coupons generated by apps in COUPON_PLUGINS
            // these are typically retargeting coupons so we don't want to show them
            // NOTE: in case generic coupons are created, those will not show up so
            // we do not blanket ban non-shopify coupons for now
            if (in_array($value['app']['developerName'], self::COUPON_PLUGINS) === true)
            {
                continue;
            }

            if (($value['customerSelection']['forAllCustomers'] !== null && $value['customerSelection']['forAllCustomers'] === false)
            || ($value['itemEntitlements']['targetAllLineItems'] !== null && $value['itemEntitlements']['targetAllLineItems'] === false))
            {
                continue;
            }

            // skip free shipping in v1
            if ($value['target'] == 'SHIPPING_LINE')
            {
                continue;
                // if(($value['prerequisiteShippingPriceRange'] !== null && $value['prerequisiteShippingPriceRange']['lessThanOrEqualTo'] > $amount)
                // || (empty($value['shippingEntitlements']['countryCodes']) === false && in_array($countryCode,$value['shippingEntitlements']['countryCodes']) === false)
                // ){
                //     continue;
                // }
            }

            // validation for min amount and expire date
            $dateTimeNow = date('Y-m-d H:i:s');
            if (($amount < $discountMinAmount)
                || ($minQuantityRange !== null && $minQuantityRange > $orderQuantity)
                || ($discountStartDate !== null && strtotime($discountStartDate) > time())
                || ($dicountEndDate !== null && strtotime($dicountEndDate) < $dateTimeNow))
            {
                continue;
            }

            $count = $value['usageCount'];

            $limit = $value['usageLimit'];

            // NOTE: usage limit is not always reliable
            // look at checking the limit in case of bulk discount codes as
            // they can be generated after the price rule and usage count is set
            if (empty($count) === false && empty($limit) === false)
            {
                if ($limit - $count <=  0)
                {
                    continue;
                }
            }

            $this->addDiscountCode($value, $promotions);
        }

        return ['promotions' => $promotions];
    }

    public function applyCoupon($input, $checkoutId)
    {
        $client = $this->getShopifyClientByMerchant();

        $mutation = (new Mutations)->applyCouponMutation();

        $graphqlQuery = [
            'query'     => $mutation,
            'variables' => [
                'discountCode' => $input['code'],
                'checkoutId'   => $checkoutId,
            ],
        ];

        $response = $client->sendStorefrontRequest(json_encode($graphqlQuery));

        $response = json_decode($response, true);

        // Unexpected errors that need to be fixed.
        if (empty($response['errors']) === false)
        {
            return $this->getInvalidCouponApplicationResponse($input, $response, self::APPLY_COUPON_API_ERROR);
        }

        $data = $response['data']['checkoutDiscountCodeApplyV2'];

        $checkout = $data['checkout'];

        // Errors due to user input, we need to catalog the possible error codes returned.
        if (empty($data['checkoutUserErrors']) === false || empty($checkout['discountApplications']['edges']) === true)
        {
            return $this->getInvalidCouponApplicationResponse($input, $response, self::APPLY_COUPON_API_CHECKOUT_USER_ERROR);
        }

        $promotions = $checkout['discountApplications']['edges'][0]['node'];

        // User entered valid code but cart item validation failed.
        if ($promotions['applicable'] !== true)
        {
            return $this->getInvalidCouponApplicationResponse($input, $response, self::APPLY_COUPON_NOT_APPLICABLE);
        }

        $value = (new Utils)->formatNumber($checkout['lineItemsSubtotalPrice']['amount'] - $checkout['subtotalPrice']['amount']) * 100;

        if($this->merchant->getId() === 'ChdCdGm7TvuVk6')
        {
            $atLeastOneItemHasCouponTag = false;
            $floorValue = 0;
            $lineItems = $checkout['lineItems']['edges'];
            foreach($lineItems as $lineItem){
                $tags = $lineItem['node']['variant']['product']['tags'] ?? [];
                $quantity = $lineItem['node']['quantity'] ?? 0;

                $lineItemHasCouponTag = false;
                $lineItemFloorValue = 0;
                foreach ($tags as $tag){
                    if(strtolower($tag) === strtolower($promotions['code']))
                    {
                        $lineItemHasCouponTag = true;
                    }
                    else
                    {
                        $tagArray = explode('magic_floor_',$tag);
                        if(count($tagArray) > 1){
                            $currentFloorValue = (int)$tagArray[1];
                            if($currentFloorValue > $lineItemFloorValue)
                            {
                                $lineItemFloorValue = $currentFloorValue;
                            }
                        }
                    }
                }
                if ($lineItemHasCouponTag){
                    $atLeastOneItemHasCouponTag = true;
                    $floorValue = $floorValue + $lineItemFloorValue * $quantity;
                }
                else{
                    $price = (new Utils)->formatNumber($lineItem['node']['variant']['price']['amount']);
                    $floorValue = $floorValue + $price * $quantity;
                }
            }

            $totalDiscountedPrice = (new Utils)->formatNumber($checkout['subtotalPrice']['amount']) * 100;
            $floorValue = $floorValue * 100;
            if($totalDiscountedPrice < $floorValue && $atLeastOneItemHasCouponTag)
            {
                $value = (new Utils)->formatNumber($checkout['lineItemsSubtotalPrice']['amount']) * 100 - $floorValue;
            }
            $value = $value < 0 ? 0 : $value;
        }

        return [
            'response' => [
                'promotion' => [
                    'code'          => $promotions['code'],
                    'reference_id'  => $promotions['code'],
                    'value'         => (int)$value,
                ],
            ],
            'status_code' => 200,
        ];
    }

    // Removes coupon from Shopify Checkout
    // Imp for more advanced coupons such as b1g1
    public function removeCoupon(string $checkoutId)
    {
        $client = $this->getShopifyClientByMerchant();

        $mutation = (new Mutations)->removeCouponMutation();

        $graphqlQuery = array('query' => $mutation);

        $graphqlQuery = [
            'query'     => $mutation,
            'variables' => [
                'checkoutId' => $checkoutId,
            ],
        ];

        return $client->sendStorefrontRequest(json_encode($graphqlQuery));
    }

    // Updates the email in Shopify Checkout
    public function updateCheckoutEmail(string $checkoutId, string $email)
    {
        $client = $this->getShopifyClientByMerchant();

        $mutation = (new Mutations)->getcheckoutEmailUpdateMutation();

        $graphqlQuery = [
            'query'     => $mutation,
            'variables' => [
                'checkoutId' => $checkoutId,
                'email'      => $email,
            ],
        ];

        $this->trace->info(
            TraceCode::SHOPIFY_1CC_UPDATE_EMAIL_BODY,
            ['checkoutId' => $checkoutId]);

        return $client->sendStorefrontRequest(json_encode($graphqlQuery));
    }

    protected function addDiscountCode(array $value, array &$promotions)
    {
        foreach($value['discountCodes']['edges'] as $node)
        {
            $discountCodeNode = $node['node'];
            if (empty($discountCodeNode) === false)
            {
                array_push(
                  $promotions,
                  [
                      'code'    => $discountCodeNode['code'],
                      'summary' => $value['summary'],
                      'tnc'     => []
                  ]);
            }
        }
    }

    // Returns Shopify Client based on current set merchant
    protected function getShopifyClientByMerchant()
    {
        $creds = (new AuthConfig\Core)->getShopify1ccConfig($this->merchant->getId());
        if (empty($creds) === true)
        {
            throw new Exception\BadRequestException(ErrorCode::BAD_REQUEST_ERROR_MERCHANT_SHOPIFY_ACCOUNT_NOT_CONFIGURED);
        }
        return new Client($creds);
    }

    /**
     * @param $input
     * @param $response
     * @return array
     */
    protected function getInvalidCouponApplicationResponse(array $input, array $response, string $errorType): array
    {
        $this->pushMetricIfApplicable($response, $errorType);
        // TODO: Trim error logs after some time.
        $this->trace->error(
            TraceCode::SHOPIFY_1CC_APPLY_COUPON_ERROR,
            [
                'input'    => $input,
                'response' => $response,
            ]);
        return (new Errors)->getInvalidCouponApplicationResponse();
    }

    // Log critical errors or checkout user errors that are unknown to us (considered unsafe).
    protected function pushMetricIfApplicable(array $response, string $errorType): void
    {
        if (
            ($errorType === self::APPLY_COUPON_API_ERROR) ||
            (
                empty($response['data']['checkoutDiscountCodeApplyV2']['checkoutUserErrors']) === false &&
                $this->isCheckoutUserErrorSafe($response) === false
            )
        )
        {
            $this->monitoring->addTraceCount(Metric::SHOPIFY_1CC_APPLY_COUPON_FAILURE_COUNT, ['error_type' => $errorType]);
        }
        return;
    }

    // TODO: Missing discount edges is not checked. Need more data before we can add it to the safe error list.
    protected function isCheckoutUserErrorSafe(array $response): bool
    {
        $isSafe = false;
        $checkoutDiscountCodeApplyV2 = $response['data']['checkoutDiscountCodeApplyV2'];
        $checkoutUserErrors = $checkoutDiscountCodeApplyV2['checkoutUserErrors'];
        // As this is an array it may return an unsafe error code so we iterate over
        // all codes instead of breaking in the middle.
        foreach ($checkoutUserErrors as $index => $value)
        {
            $isSafe = in_array($value['code'], self::SHOPIFY_CHECKOUT_USER_ERROR_CODES_DUE_TO_USER_INPUT);
        }
        return $isSafe;
    }
}
