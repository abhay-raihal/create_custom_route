<?php

namespace RZP\Models\BankingAccount;

use RZP\Constants\Mode;
use RZP\Models\Base;
use RZP\Models\Merchant\RazorxTreatment;
use RZP\Models\Payout;
use RZP\Models\Merchant;
use RZP\Constants\Table;
use RZP\Trace\TraceCode;
use RZP\Models\Admin\Admin;
use RZP\Models\FeeRecovery;
use RZP\Models\Merchant\Balance;
use RZP\Models\Merchant\Attribute;
use RZP\Http\BasicAuth\BasicAuth;
use RZP\Models\BankingAccount\State;
use RZP\Models\Base\PublicCollection;
use Illuminate\Database\Eloquent\Model;
use RZP\Constants\Product;

use RZP\Models\BankingAccount\Activation\Detail\Entity as ActivationDetails;

/**
 * @property Merchant\Entity            $merchant
 * @property Merchant\Balance\Entity    $balance
 */
class Entity extends Base\PublicEntity
{
    const ID                                = 'id';
    const CHANNEL                           = 'channel';
    const ACCOUNT_NUMBER                    = 'account_number';
    const ACCOUNT_IFSC                      = 'account_ifsc';
    const ACCOUNT_CURRENCY                  = 'account_currency';
    const ACCOUNT_ACTIVATION_DATE           = 'account_activation_date';
    const MERCHANT                          = 'merchant';

    /**
     * Pincode field is being used to store the pincode entered by Merchant
     * while raising request for account creation. This may or may not
     * be same as the account pincode. This field serves the purpose of storing
     * the requested pincode.
     *
     * @var string
     */
    const PINCODE                           = 'pincode';
    const STATUS                            = 'status';
    const SUB_STATUS                        = 'sub_status';
    const BANK_INTERNAL_STATUS              = 'bank_internal_status';
    const FTS_FUND_ACCOUNT_ID               = 'fts_fund_account_id';
    const BALANCE_ID                        = 'balance_id';

    const GATEWAY_BALANCE                   = 'gateway_balance';
    const BALANCE_LAST_FETCHED_AT           = 'balance_last_fetched_at';

    const ACCOUNT_STATEMENT_LAST_UPDATED_AT = 'account_statement_last_updated_at';
    const STATUS_LAST_UPDATED_AT            = 'status_last_updated_at';

    // For tracking Last statement fetch attempt for merchant
    // This field is being used to schedule merchant next fetch using cron
    const LAST_STATEMENT_ATTEMPT_AT = 'last_statement_attempt_at';

    /**
     * Bank reference number is generated by Razorpay to communicate with bank.
     * The logic to generate this field could be different for different banks.
     *
     * @var string
     */
    const BANK_REFERENCE_NUMBER             = 'bank_reference_number';

    /**
     * Bank internal reference number is generated by the bank and
     * is communicated to Razorpay in the webhook/responses
     *
     * @var string
     */
    const BANK_INTERNAL_REFERENCE_NUMBER    = 'bank_internal_reference_number';

    const BENEFICIARY_ADDRESS1              = 'beneficiary_address1';
    const BENEFICIARY_ADDRESS2              = 'beneficiary_address2';
    const BENEFICIARY_ADDRESS3              = 'beneficiary_address3';
    const BENEFICIARY_EMAIL                 = 'beneficiary_email';
    const BENEFICIARY_MOBILE                = 'beneficiary_mobile';

    /**
     * This field stores the pincode for which the account is opened.
     * It could be different from Pincode requested by the Merchant initially.
     * Once the account is opened, this field value will be used everywhere to
     * populate pincode information
     *
     * @var string
     */
    const BENEFICIARY_PIN                   = 'beneficiary_pin';

    const BENEFICIARY_CITY                  = 'beneficiary_city';
    const BENEFICIARY_STATE                 = 'beneficiary_state';
    const BENEFICIARY_COUNTRY               = 'beneficiary_country';
    const BENEFICIARY_NAME                  = 'beneficiary_name';


    const PINCODE_LENGTH                    = 6;
    const ACCOUNT_NUMBER_LENGTH             = 40;
    const ACCOUNT_IFSC_LENGTH               = 11;

    // TODO: move username, password, reference1 to banking_account_details
    // JIRA ticket: https://razorpay.atlassian.net/browse/RX-608

    // for rbl this is ldap id
    const USERNAME                          = 'username';
    // for rbl this is ldap password
    const PASSWORD                          = 'password';
    // For rbl this is the corp_id
    const REFERENCE1                        = 'reference1';

    const ACCOUNT_TYPE                      = 'account_type';

    const INTERNAL_COMMENT                  = 'internal_comment';

    const VAULT_NAMESPACE                   = 'banking_accounts_creds';

    const PINCODES      = 'pincodes';
    const ACTION        = 'action';

    const DETAILS                 = 'details';
    const ACTIVATION_DETAIL       = 'activation_detail';

    // Constants for fee recovery details
    const LAST_DEDUCTED_AT   = 'last_deducted_at';
    const OUTSTANDING_AMOUNT = 'outstanding_amount';

    // Relation Constants
    const BANKING_ACCOUNT_DETAILS            = 'banking_account_details';
    const BANKING_ACCOUNT_ACTIVATION_DETAILS = 'banking_account_activation_details';
    const BANKING_ACCOUNT_CALL_LOG           = 'activation_call_log';
    const BALANCE                            = 'balance';
    const REVIEWERS                          = 'reviewers';
    const SPOCS                              = 'spocs';
    const OPS_MX_POCS                        = 'ops_mx_pocs';
    const FEE_RECOVERY_DETAILS               = 'fee_recovery_details';
    const BANKING_ACCOUNT_CA_SPOC_DETAILS    = 'banking_account_ca_spoc_details';


    // Constants for reviewers() and spocs and ops_mx_poc relation
    const REVIEWER_ID             = 'reviewer_id';
    const SALES_POC_ID            = 'sales_poc_id';
    const ADMIN_ID                = 'admin_id';
    const BANKING_ACCOUNT_IDS     = 'banking_account_ids';
    const AUDITOR_TYPE            = 'auditor_type';
    const ENTITY                  = 'entity';
    const ENTITY_ID               = 'entity_id';
    const PENDING_ON              = 'pending_on';
    const OPS_MX_POC              = 'ops_mx_poc';
    const OPS_MX_POC_ID           = 'ops_mx_poc_id';

    const IDS           = 'ids';

    // Additional attributes to search from admin dashboard
    const MERCHANT_BUSINESS_NAME  = 'merchant_business_name';
    const MERCHANT_EMAIL = 'merchant_email';
    const MERCHANT_POC_CITY = 'merchant_poc_city';
    const IS_DOCUMENTS_WALKTHROUGH_COMPLETE = 'is_documents_walkthrough_complete';
    const SALES_TEAM = 'sales_team';
    const BOOKING_DATE_AND_TIME = 'booking_date_and_time';
    const BUSINESS_PAN_VALIDATION = 'business_pan_validation';
    const DECLARATION_STEP = 'declaration_step';
    const APPLICATION_TYPE = 'application_type';
    const BUSINESS_CATEGORY = 'business_category';
    const BANK_ACCOUNT_TYPE = 'bank_account_type';
    const ASSIGNEE_TEAM = 'assignee_team';
    const SOURCE = 'source';
    const FILTER_SLOT_BOOKED = 'filter_slot_booked';
    const SORT_SLOT_BOOKED = 'sort_slot_booked';
    const FROM_SLOT_BOOKED = 'from_slot_booked';
    const TO_SLOT_BOOKED = 'to_slot_booked';
    const FROM_FOLLOW_UP_DATE = 'from_follow_up_date';
    const TO_FOLLOW_UP_DATE = 'to_follow_up_date';
    const SORT_FOLLOW_UP_DATE = 'sort_follow_up_date';
    const LATEST_FOLLOW_UP_DATE = 'latest_follow_up_date';
    const CLARITY_CONTEXT       = 'clarity_context'; // used for filtering banking accounts
    const FOS_CITY = 'fos_city';
    const FROM_OPS_FOLLOW_UP_DATE = 'from_ops_follow_up_date';
    const TO_OPS_FOLLOW_UP_DATE = 'to_ops_follow_up_date';
    const SKIP_DWT = 'skip_dwt';
    const FROM_DOCKET_ESTIMATED_DELIVERY_DATE = 'from_docket_estimated_delivery_date';
    const TO_DOCKET_ESTIMATED_DELIVERY_DATE = 'to_docket_estimated_delivery_date';
    const EXCLUDE_STATUS = 'exclude_status';

    // Fields to apply filters common for admin dashboard and partner LMS
    const FILTER_MERCHANTS = 'filter_merchants';
    const BANK_POC_USER_ID = 'bank_poc_user_id';

    // For experimentation - resolved from merchant preferences - group x_merchant_current_accounts
    const USING_NEW_STATES = 'using_new_states';
    const OLD_STATE_MACHINE = 'old';
    const NEW_STATE_MACHINE = 'new';
    const FASTER_DOC_COLLECTION_ENABLED = 'faster_doc_collection_enabled';

    // Response attributes
    const BALANCE_TYPE       = 'balance_type';
    const BANKING_ACCOUNT_ID = 'banking_account_id';

    // Slack channel for alerts
    const RX_CA_RBL_ALERTS  = 'rx_ca_rbl_alerts';

    const ERROR = 'error';

    // RM_NAME possible strings
    const RM_NOT_MAP = 'rm not map';
    const RM_NOT_MAP_BY_BM = 'rm not map by bm';
    const RM_NOT_ASSIGNED = 'rm not assigned';
    const RM_NAME_EMPTY = '';

    const MASTER_BANKING_ACCOUNT = 'master_banking_account';

    // Current Account Channels
    const Neostone = 'neostone';

    public static $rm_name_missing_possibilities = [
        self::RM_NOT_MAP,
        self::RM_NOT_MAP_BY_BM,
        self::RM_NAME_EMPTY,
        self::RM_NOT_ASSIGNED
    ];

    protected $entity = 'banking_account';

    public $feeRecoverySetFlag = true;

    protected static $sign = 'bacc';

    protected $generateIdOnCreate = true;

    protected $fillable = [
        self::ID,
        self::CHANNEL,
        self::ACCOUNT_NUMBER,
        self::ACCOUNT_IFSC,
        self::STATUS,
        self::SUB_STATUS,
        self::PINCODE,
        self::BANK_REFERENCE_NUMBER,
        self::BANK_INTERNAL_STATUS,
        self::USERNAME,
        self::PASSWORD,
        self::REFERENCE1,
        self::BENEFICIARY_PIN,
        self::BENEFICIARY_MOBILE,
        self::BENEFICIARY_EMAIL,
        self::BENEFICIARY_ADDRESS1,
        self::BENEFICIARY_ADDRESS2,
        self::BENEFICIARY_ADDRESS3,
        self::BENEFICIARY_CITY,
        self::BENEFICIARY_STATE,
        self::BENEFICIARY_COUNTRY,
        self::ACCOUNT_ACTIVATION_DATE,
        self::BENEFICIARY_NAME,
        self::ACCOUNT_TYPE,
        self::BANK_INTERNAL_REFERENCE_NUMBER,
        self::BENEFICIARY_MOBILE,
        self::BENEFICIARY_EMAIL,
        self::FTS_FUND_ACCOUNT_ID,
        self::INTERNAL_COMMENT,
        self::GATEWAY_BALANCE,
        self::BALANCE_LAST_FETCHED_AT,
    ];

    protected $visible = [
        self::ID,
        self::STATUS,
        self::SUB_STATUS,
        self::PINCODE,
        self::CHANNEL,
        self::USERNAME,
        self::REFERENCE1,
        self::CREATED_AT,
        self::UPDATED_AT,
        self::BALANCE_ID,
        self::MERCHANT_ID,
        self::ACCOUNT_IFSC,
        self::ACCOUNT_NUMBER,
        self::ACCOUNT_CURRENCY,
        self::BENEFICIARY_MOBILE,
        self::BENEFICIARY_EMAIL,
        self::BENEFICIARY_CITY,
        self::BENEFICIARY_STATE,
        self::FTS_FUND_ACCOUNT_ID,
        self::BENEFICIARY_ADDRESS1,
        self::BENEFICIARY_ADDRESS2,
        self::BENEFICIARY_ADDRESS3,
        self::BENEFICIARY_PIN,
        self::BANK_INTERNAL_STATUS,
        self::ACCOUNT_TYPE,
        self::BANK_REFERENCE_NUMBER,
        self::BENEFICIARY_COUNTRY,
        self::BENEFICIARY_NAME,
        self::BENEFICIARY_MOBILE,
        self::BENEFICIARY_EMAIL,
        self::ACCOUNT_ACTIVATION_DATE,
        self::BANK_INTERNAL_REFERENCE_NUMBER,
        self::MERCHANT,
        self::INTERNAL_COMMENT,
        self::BALANCE,
        self::BANKING_ACCOUNT_DETAILS,
        self::BANKING_ACCOUNT_ACTIVATION_DETAILS,
        self::LAST_STATEMENT_ATTEMPT_AT,
        self::GATEWAY_BALANCE,
        self::BALANCE_LAST_FETCHED_AT,
        //
        // This has been added so that banking_account_details
        // relations can be fetched on admin auth.
        // For some reason admin auth expects the relations to be
        // present in visible array as camel cased.
        // For proxy auth this is not required, having snake cased
        // 'banking_account_details' works fine
        //
        'bankingAccountDetails',
        'bankingAccountActivationDetails',
        self::BANKING_ACCOUNT_CALL_LOG,
        // This is to enable sorting on this column from call logs entity
        self::LATEST_FOLLOW_UP_DATE,
        self::USING_NEW_STATES,
        'activationCallLog',
        'activationComments',
        'opsMxPocs',
        self::REVIEWERS,
        self::SPOCS,
        self::OPS_MX_POCS,
        self::PASSWORD,
        self::MASTER_BANKING_ACCOUNT,
    ];

    protected $public = [
        self::ID,
        self::ENTITY,
        self::CHANNEL,
        self::STATUS,
        self::SUB_STATUS,
        self::MERCHANT_ID,
        self::ACCOUNT_NUMBER,
        self::ACCOUNT_IFSC,
        self::BANK_INTERNAL_STATUS,
        self::REFERENCE1,
        self::ACCOUNT_TYPE,
        self::ACCOUNT_CURRENCY,
        self::BENEFICIARY_EMAIL,
        self::BENEFICIARY_MOBILE,
        self::BENEFICIARY_NAME,
        self::BANK_REFERENCE_NUMBER,
        self::PINCODE,
        self::BANKING_ACCOUNT_DETAILS,
        self::BANKING_ACCOUNT_ACTIVATION_DETAILS,
        self::BALANCE,
        self::FEE_RECOVERY_DETAILS,
        self::ACCOUNT_STATEMENT_LAST_UPDATED_AT,
        self::STATUS_LAST_UPDATED_AT,
        self::BANKING_ACCOUNT_CA_SPOC_DETAILS,
        self::USING_NEW_STATES,
        self::FASTER_DOC_COLLECTION_ENABLED,
        self::MASTER_BANKING_ACCOUNT,
    ];

    protected $relations = [
        self::BANKING_ACCOUNT_DETAILS,
        self::BANKING_ACCOUNT_ACTIVATION_DETAILS,
    ];

    protected $publicSetters = [
        self::ID,
        self::BALANCE,
        self::BANKING_ACCOUNT_DETAILS,
        self::FEE_RECOVERY_DETAILS,
        self::ACCOUNT_STATEMENT_LAST_UPDATED_AT,
        self::STATUS_LAST_UPDATED_AT,
        self::BANKING_ACCOUNT_ACTIVATION_DETAILS,
        self::USING_NEW_STATES,
        self::FASTER_DOC_COLLECTION_ENABLED,
    ];

    // ---------------------------- Setters ----------------------------------- //

    public function setStatus(string $status)
    {
        if ($this->isSharedChannel() === true)
        {
            $this->setAttribute(self::STATUS, $status);

            return;
        }

        if ($this->isCorpCardChannel() === true)
        {
            $this->setAttribute(self::STATUS, $status);

            return;
        }

        if ($this->getStatus() === null)
        {
            Status::validateInInitialStatuses($status);

            $this->setAttribute(self::STATUS, $status);

            return;
        }

        if ($this->isDirty(Entity::STATUS) === false)
        {
            return;
        }

        $originalStatus = $this->getRawOriginal(Entity::STATUS);

        $newStatus = $this->getStatus();

        $subStatus = $this->getRawOriginal(Entity::SUB_STATUS);

        Status::validatePreviousToCurrentMapping($originalStatus, $newStatus, $subStatus);

        if ($newStatus === Status::PROCESSED)
        {
            (new Validator)->setStrictFalse()->validateInput(Validator::PROCESSED_STATUS, $this->toArray());
        }

        if ($newStatus === Status::ACTIVATED)
        {
            (new Validator)->setStrictFalse()->validateInput(Validator::ACTIVATED_STATUS, $this->toArray());
        }
    }

    public function setSubStatus($substatus)
    {
//        // empty strings are converted to NULL.
//        $substatus = (empty($substatus) === true) ? null : $substatus;

        Status::validateStatusSubstatusMapping($this->getStatus(), $substatus);

        Status::validateSubStatusPrerequisites($this,$substatus);

        $this->setAttribute(self::SUB_STATUS, $substatus);
    }

    public function setBankReferenceNumber(string $number)
    {
        $this->setAttribute(self::BANK_REFERENCE_NUMBER, $number);
    }

    public function setBankInternalStatus(string $internalStatus)
    {
        $this->setAttribute(self::BANK_INTERNAL_STATUS, $internalStatus);
    }

    public function setFtsFundAccountId(string $fundAccountId)
    {
        $this->setAttribute(self::FTS_FUND_ACCOUNT_ID, $fundAccountId);
    }

    public function setPassword(string $password)
    {
        $this->setAttribute(self::PASSWORD, $password);
    }

    public function setLastStatementAttemptAt(int $currentTime)
    {
        $this->setAttribute(self::LAST_STATEMENT_ATTEMPT_AT, $currentTime);
    }

    public function setGatewayBalance($balance)
    {
        $this->setAttribute(self::GATEWAY_BALANCE, $balance);
    }

    public function setBalanceLastFetchedAt(int $time)
    {
        $this->setAttribute(self::BALANCE_LAST_FETCHED_AT, $time);
    }

    // -------------------------- Getters ------------------------------------ //

    public function getChannel()
    {
        return $this->getAttribute(self::CHANNEL);
    }

    public function getBalanceId()
    {
        return $this->getAttribute(self::BALANCE_ID);
    }

    public function getStatus()
    {
        return $this->getAttribute(self::STATUS);
    }

    public function getStatusForExternalDisplay()
    {
        return Status::transformFromInternalToExternal($this->getStatus());
    }

    public function getSubStatus()
    {
        return $this->getAttribute(self::SUB_STATUS);
    }

    public function getBalance()
    {
        return $this->getAttribute(self::BALANCE);
    }

    public function getSubStatusForExternalDisplay()
    {
        return Status::transformSubStatusFromInternalToExternal($this->getSubStatus());
    }

    public function getBankReferenceNumber()
    {
        return $this->getAttribute(self::BANK_REFERENCE_NUMBER);
    }

    public function getAccountIfsc()
    {
        return $this->getAttribute(self::ACCOUNT_IFSC);
    }

    public function getAccountActivationDate()
    {
        return $this->getAttribute(self::ACCOUNT_ACTIVATION_DATE);
    }

    public function getAccountNumber()
    {
        return $this->getAttribute(self::ACCOUNT_NUMBER);
    }

    public function getBeneficiaryName()
    {
        return $this->getAttribute(self::BENEFICIARY_NAME);
    }

    public function getBeneficiaryCity()
    {
        return $this->getAttribute(self::BENEFICIARY_CITY);
    }

    public function getBeneficiaryEmail()
    {
        return $this->getAttribute(self::BENEFICIARY_EMAIL);
    }

    public function getBeneficiaryState()
    {
        return $this->getAttribute(self::BENEFICIARY_STATE);
    }

    public function getBeneficiaryMobile()
    {
        return $this->getAttribute(self::BENEFICIARY_MOBILE);
    }

    public function getInternalReferenceNumber()
    {
        return $this->getAttribute(self::BANK_INTERNAL_REFERENCE_NUMBER);
    }

    public function getBeneficiaryAddress1()
    {
        return $this->getAttribute(self::BENEFICIARY_ADDRESS1);
    }

    public function getBeneficiaryAddress2()
    {
        return $this->getAttribute(self::BENEFICIARY_ADDRESS2);
    }

    public function getBeneficiaryAddress3()
    {
        return $this->getAttribute(self::BENEFICIARY_ADDRESS3);
    }

    public function getBeneficiaryPin()
    {
        return $this->getAttribute(self::BENEFICIARY_PIN);
    }

    public function getBeneficiaryCountry()
    {
        return $this->getAttribute(self::BENEFICIARY_COUNTRY);
    }

    public function getBankName()
    {
        return $this->getAttribute(self::CHANNEL);
    }

    public function getFtsFundAccountId()
    {
        return $this->getAttribute(self::FTS_FUND_ACCOUNT_ID);
    }

    public function getAccountType()
    {
        return $this->getAttribute(self::ACCOUNT_TYPE);
    }

    public function getUsername()
    {
        return $this->getAttribute(self::USERNAME);
    }

    public function getPassword()
    {
        return $this->getAttribute(self::PASSWORD);
    }

    public function isAccountActivationDateFilled()
    {
        return ($this->isAttributeNotNull(self::ACCOUNT_ACTIVATION_DATE));
    }

    public function getReference1()
    {
        return $this->getAttribute(self::REFERENCE1);
    }

    public function getBankInternalStatus()
    {
        return $this->getAttribute(self::BANK_INTERNAL_STATUS);
    }

    public function getDetailsDataUsingKey($key)
    {
        return $this->bankingAccountDetails()->where(Detail\Entity::GATEWAY_KEY, $key)
                                             ->value(Detail\Entity::GATEWAY_VALUE);
    }

    public function getPincode()
    {
        return $this->getAttribute(self::PINCODE);
    }

    public function getGatewayBalance()
    {
        return $this->getAttribute(self::GATEWAY_BALANCE);
    }

    public function getBalanceLastFetchedAt()
    {
        return $this->getAttribute(self::BALANCE_LAST_FETCHED_AT);
    }

    public function getStatusLastUpdatedAt()
    {
        $lastUpdatedAt = null;

        $statusChangeLog = $this->activationStates()->get()->toArray();

        $currentStatus = $this->getStatus();

        foreach (array_reverse($statusChangeLog) as $statusChange)
        {
            if ($statusChange[self::STATUS] === $currentStatus)
            {
                $lastUpdatedAt = $statusChange[self::CREATED_AT];
            }
            else
            {
                break;
            }
        }

        return $lastUpdatedAt;
    }

    public function setMasterBankingAccount($masterBankingAccount)
    {
        $this->setAttribute(self::MASTER_BANKING_ACCOUNT, $masterBankingAccount);
    }

    // --------------------------- Relations ---------------------------------- //

    public function merchant()
    {
        return $this->belongsTo(Merchant\Entity::class);
    }

    public function balance()
    {
        return $this->belongsTo(Balance\Entity::class);
    }

    public function reviewers()
    {
        return $this->morphToMany(Admin\Entity::class, self::ENTITY, Table::ADMIN_AUDIT_MAP, self::ENTITY_ID, Entity::ADMIN_ID)
                    ->withPivot(Entity::AUDITOR_TYPE)
                    ->where(Entity::AUDITOR_TYPE, '=', 'reviewer');
    }

    // Sales POCs
    public function spocs()
    {
        return $this->morphToMany(Admin\Entity::class, self::ENTITY, Table::ADMIN_AUDIT_MAP, self::ENTITY_ID, Entity::ADMIN_ID)
                    ->withPivot(Entity::AUDITOR_TYPE)
                    ->where(Entity::AUDITOR_TYPE, '=', 'spoc');
    }

    // Merchant-facing external/ops POCs
    public function opsMxPocs()
    {
        return $this->morphToMany(Admin\Entity::class, self::ENTITY, Table::ADMIN_AUDIT_MAP, self::ENTITY_ID, Entity::ADMIN_ID)
                    ->withPivot(Entity::AUDITOR_TYPE)
                    ->where(Entity::AUDITOR_TYPE, '=', Entity::OPS_MX_POC);
    }

    public function activationStates()
    {
        return $this->hasMany('\RZP\Models\BankingAccount\State\Entity');
    }

    public function bankingAccountActivationDetails()
    {
        return $this->hasOne(Activation\Detail\Entity::class);
    }

    public function activationComments()
    {
        return $this->hasMany(Activation\Comment\Entity::class);
    }

    public function activationCallLog()
    {
        return $this->hasMany(Activation\CallLog\Entity::class);
    }

    /**
     * This function is used for getting the activation status change log of a banking account
     *
     * @return PublicCollection
     */
    public function getActivationStatusChangeLog(): PublicCollection
    {
        return $this->activationStates()
                    ->orderBy(State\Entity::CREATED_AT)
                    ->get();
    }

    public function getActivationComments(): PublicCollection
    {
        return $this->activationComments()
                    ->orderBy(Activation\Comment\Entity::ADDED_AT)
                    ->get();
    }

    public function getLatestActivationComment()
    {
        return $this->getActivationComments()
                    ->first();
    }

    public function bankingAccountDetails()
    {
        return $this->hasMany(Detail\Entity::class, Detail\Entity::BANKING_ACCOUNT_ID, self::ID);
    }

    public function getActivationCallLog(): PublicCollection
    {
        return $this->activationCallLog()
                    ->orderBy(Model::CREATED_AT)
                    ->get();
    }

    public function getOpsMxPocs()
    {
        return $this->opsMxPocs()
                    ->orderBy(Model::CREATED_AT)
                    ->get();
    }
    // ----------------------- Public setters ---------------------------------

    public function setPublicFeeRecoveryDetailsAttribute(array & $array)
    {
        if (app('basicauth')->isProxyAuth() === true)
        {
            $balance = optional($this->balance);

            if (($balance->isAccountTypeDirect() === true) and
                ($balance->isTypeBanking() === true) and
                ($balance->getChannel() === Channel::RBL) and
                ($this->feeRecoverySetFlag === true))
            {
                $latestFeeRecoveryPayout = (new Payout\Repository)->fetchFeeLastDeductedAt($this->getMerchantId(),
                                                                                  $balance->getId());

                app('trace')->info(
                    TraceCode::BANKING_ACCOUNT_OUTSTANDING_AMOUNT,
                    [
                        'balance_id'       => $balance->getId(),
                        'merchant_id'      => $this->getMerchantId(),
                        'fee_recovery'     => $this->feeRecoverySetFlag,
                    ]);

                $outstandingAmount = $this->fetchOutstandingAmountToBeRecovered();

                $array[self::FEE_RECOVERY_DETAILS] = [
                    self::OUTSTANDING_AMOUNT => $outstandingAmount,
                    self::LAST_DEDUCTED_AT   => optional($latestFeeRecoveryPayout)->getProcessedAt()
                ];
            }
        }
    }

    public function setPublicBankingAccountDetailsAttribute(array & $array)
    {
        if (app('basicauth')->isAdminAuth() === false)
        {
            unset($array[self::BANKING_ACCOUNT_DETAILS]);
        }
    }

    public function setPublicBankingAccountActivationDetailsAttribute(array & $array)
    {
        if(app('basicauth')->isProxyAuth() === true && $array[self::ACCOUNT_TYPE] === AccountType::CURRENT)
        {
            if($this->bankingAccountActivationDetails !== null)
            {
                $rmName = null;

                $bankingAccountActivationDetails = $this->bankingAccountActivationDetails;

                $rmNameInLowerCaseWithTrimApplied = strtolower(trim($bankingAccountActivationDetails[Activation\Detail\Entity::RM_NAME]));

                if(in_array($rmNameInLowerCaseWithTrimApplied, self::$rm_name_missing_possibilities) === false)
                {
                    $rmName = $bankingAccountActivationDetails[Activation\Detail\Entity::RM_NAME];
                }

                if (array_key_exists('banking_account_activation_details', $array) === true)
                {
                    $array['banking_account_activation_details'][Activation\Detail\Entity::RM_NAME] = $rmName;
                }

                if($this->spocs()->first() !== null)
                {
                    $bankingAccountActivationDetails = $this->bankingAccountActivationDetails;

                    $salesSpoc = $this->spocs()->first()->toArrayPublic();

                    $array[self::BANKING_ACCOUNT_CA_SPOC_DETAILS] =
                        [
                            Activation\Detail\Entity::RM_NAME                  => $rmName,
                            Activation\Detail\Entity::RM_PHONE_NUMBER          => $bankingAccountActivationDetails[Activation\Detail\Entity::RM_PHONE_NUMBER],
                            Activation\Detail\Entity::SALES_POC_PHONE_NUMBER   => $bankingAccountActivationDetails[Activation\Detail\Entity::SALES_POC_PHONE_NUMBER],
                            Activation\Detail\Entity::SALES_POC_NAME           => $salesSpoc['name'],
                            Activation\Detail\Entity::SALES_POC_EMAIL          => $salesSpoc['email']
                        ];
                }
            }
        }
    }

    public function setPublicBalanceAttribute(array & $array)
    {
        /** @var BasicAuth $basicAuth */
        $basicAuth = app('basicauth');

        if ($basicAuth->isStrictPrivateAuth() === true and
            $basicAuth->isAppleWatchApp() === false)
        {
            unset($array[self::BALANCE]);

            return;
        }

        if (empty($this->balance))
        {
            $this->load(self::BALANCE);
        }

        $array[self::BALANCE] = optional($this->balance)->toArrayPublic();

        if ( $array[self::BALANCE] !== null)
        {
            $array[self::BALANCE] = array_intersect_key($array[self::BALANCE],
                                                        array_flip([
                                                                       Balance\Entity::ID,
                                                                       Balance\Entity::BALANCE,
                                                                       Balance\Entity::CURRENCY,
                                                                       Balance\Entity::LOCKED_BALANCE,
                                                                       Balance\Entity::LAST_FETCHED_AT,
                                                                       Balance\Entity::CORP_CARD_DETAILS,
                                                                   ]));
        }
    }

    public function setPublicAccountStatementLastUpdatedAtAttribute(array & $array)
    {
        if (app('basicauth')->isProxyAuth() === true)
        {
            /** @var Balance\Entity $balance */
            $balance = optional($this->balance);

            if (($balance->isAccountTypeDirect() === true) and
                ($balance->isTypeBanking() === true) and
                ($balance->getChannel() === Channel::RBL))
            {
                $array[self::ACCOUNT_STATEMENT_LAST_UPDATED_AT] = $balance->getLastFetchedAtAttribute();
            }
        }
    }

    public function setPublicStatusLastUpdatedAtAttribute(array &$array)
    {
        if (app('basicauth')->isProxyAuth() === true)
        {
            $array[self::STATUS_LAST_UPDATED_AT] = $this->getStatusLastUpdatedAt();
        }
    }

    /**
     *  There are two crons updating balance
     *   gateway balance fetch cron which updates gateway balance(in banking account table).
     *   acc statement fetch which also updates balance(in balance table)
     *
     *   This function checks if balance from gateway balance cron is more updated.
     *   returns true if balance fetch cron ran after acc stmt fetch cron and vice versa
     * @return bool
     */
    public function isGatewayBalanceFetchCronMoreUpdated(): bool
    {
        $balance = $this->balance;

        $gatewayBalanceLastFetchedAt = $this->getBalanceLastFetchedAt();

        $accStatementLastFetchedAt = $balance->getLastFetchedAtAttribute();

        return ($gatewayBalanceLastFetchedAt > $accStatementLastFetchedAt);
    }

    protected function isSharedChannel()
    {
        $channel = $this->getChannel();

        $allowedChannels = Channel::getAllowedSharedChannels();

        if (in_array($channel, $allowedChannels) === true)
        {
            return true;
        }

        return false;
    }

    protected function isCorpCardChannel()
    {
        $channel = $this->getChannel();

        $allowedChannels = Channel::getAllowedCorpCardChannels();

        if (in_array($channel, $allowedChannels, true) === true)
        {
            return true;
        }

        return false;
    }

    protected function fetchOutstandingAmountToBeRecovered()
    {
        $feeRecoveryRepo = new FeeRecovery\Repository;

        $unrecoveredAmountForPayouts = $feeRecoveryRepo->fetchUnrecoveredAmountForPayouts($this->getMerchantId(),
                                                                                          $this->balance->getId());

        app('trace')->info(
            TraceCode::BANKING_ACCOUNT_OUTSTANDING_AMOUNT,
            [
                'unrecovered_amount_payouts'        => $unrecoveredAmountForPayouts->toArrayPublic(),
            ]);

        $unrecoveredAmountForFailedPayouts = $feeRecoveryRepo->fetchUnrecoveredAmountForFailedPayouts($this->getMerchantId(),
                                                                                          $this->balance->getId());

        app('trace')->info(
            TraceCode::BANKING_ACCOUNT_OUTSTANDING_AMOUNT,
            [
                'unrecovered_amount_failed_payouts' => $unrecoveredAmountForFailedPayouts->toArrayPublic(),
            ]);

        $unrecoveredAmountForReversals = $feeRecoveryRepo->fetchUnrecoveredAmountForReversals($this->getMerchantId(),
                                                                                              $this->balance->getId());

        app('trace')->info(
            TraceCode::BANKING_ACCOUNT_OUTSTANDING_AMOUNT,
            [
                'unrecovered_amount_reversals'      => $unrecoveredAmountForReversals->toArrayPublic(),
            ]);

        $outstandingAmount = $unrecoveredAmountForPayouts->getAttribute(Payout\Entity::FEES) -
                             $unrecoveredAmountForFailedPayouts->getAttribute(Payout\Entity::FEES) -
                             $unrecoveredAmountForReversals->getAttribute(Payout\Entity::FEES);

        return $outstandingAmount;
    }

    public function setPublicUsingNewStatesAttribute(array &$array)
    {
        $array[self::USING_NEW_STATES] = $this->usingNewStates() ? self::NEW_STATE_MACHINE : self::OLD_STATE_MACHINE;
    }

    public function setPublicFasterDocCollectionEnabledAttribute(array &$array)
    {
        $array[self::FASTER_DOC_COLLECTION_ENABLED] = $this->isFasterDocCollectionEnabled() ? true : false;
    }

    public function getDashboardEntityLink()
    {
        $publicId = $this->getPublicId();

        // It's always needed for live mode. Not taking care of test for now.
        // TODO: make this environment aware.
        $url = "https://dashboard.razorpay.com/admin#/app/banking-accounts/$publicId";

        return $url;
    }

    //used by banking account service for creating inmemory banking_account entity for banking_accounts api
    public function setBasCaStatus(string $status)
    {
        $this->setAttribute(self::STATUS, $status);
    }

    /**
     * Returns the reference date for banking account based on the current status
     *
     * By default ActivationDetail is extracted from banking account.
     * But since activation detail can be changing with banking account,
     * we can pass the latest activation detail from which reference date will be taken
     */
    public function getReferenceDateForStatus(array $activationDetails = null)
    {
        $bankingAccountStatus = $this->getStatus();

        if ($activationDetails === null)
        {
            $activationDetails = $this->bankingAccountActivationDetails;
        }

        $followUpDate = null;

        switch ($bankingAccountStatus) {
            case Status::VERIFICATION_CALL:

                $rblActivationDetails = $activationDetails[ActivationDetails::RBL_ACTIVATION_DETAILS];

                if (isset($rblActivationDetails) === true)
                {
                    if (is_array($rblActivationDetails) === false)
                    {
                        $rblActivationDetails = json_decode($rblActivationDetails, true);
                    }

                    if (empty($rblActivationDetails[ActivationDetails::BANK_POC_ASSIGNED_DATE]) === false)
                    {
                        $followUpDate = $rblActivationDetails[ActivationDetails::BANK_POC_ASSIGNED_DATE];
                    }
                }

                break;

            case Status::DOC_COLLECTION:

                $followUpDate = $activationDetails[ActivationDetails::CUSTOMER_APPOINTMENT_DATE];
                break;

            case Status::ACCOUNT_OPENING:

                $followUpDate = $activationDetails[ActivationDetails::DOC_COLLECTION_DATE];
                break;

            case Status::API_ONBOARDING:

                $followUpDate = $activationDetails[ActivationDetails::ACCOUNT_OPEN_DATE];
                break;

            case Status::ACCOUNT_ACTIVATION:

                $followUpDate = $activationDetails[ActivationDetails::API_IR_CLOSED_DATE];
                break;

            case Status::ACTIVATED:

                $followUpDate = $activationDetails[ActivationDetails::API_IR_CLOSED_DATE];
                break;

            default:
                break;
        }

        return $followUpDate;
    }

    /**
     * This is for experimentation on leads for intruducing new state framework during Post STB
     * Read more here:
     * https://docs.google.com/spreadsheets/d/1theXYFolRsplp-mDbONthOKRXc0j4waSdQNf6UyqEdg/edit#gid=0
     *
     * TODO:
     * M2 States Experiment
     * Remove this when all new leads are onboarded to new terminal states
     * or just simply return true as all leads will eventually be using new states
     */
    public function usingNewStates()
    {
        return true;
    }

    public function isFasterDocCollectionEnabled()
    {
        $preferences = (new Attribute\Core)->fetchKeyValues(
            $this->merchant,
            Product::BANKING,
            Attribute\Group::X_MERCHANT_CURRENT_ACCOUNTS,
            [Attribute\Type::CA_ONBOARDING_FASTER_DOC_COLLECTION]
        );

        $preferences = $preferences->toArray();

        if (count($preferences) > 0)
        {
            return $preferences[0][Attribute\Entity::VALUE] === 'active';
        }

        return false;
    }

    public function isAlreadyInOldTerminalState()
    {
        $status = $this->getStatus();

        return Status::statusIsTerminal($status);
    }

    public function toArray()
    {
        // Need these relations to be set to power the notifications
        if (empty($this->spocs) === true)
        {
            $this->load(self::SPOCS);
        }

        if (empty($this->reviewers) === true)
        {
            $this->load(self::REVIEWERS);
        }

        return parent::toArray();
    }
}
